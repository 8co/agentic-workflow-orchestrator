tasks:
  - id: create-context-analyzer
    status: completed
    workflow: auto-implement
    prompt: prompts/auto-create-module.md
    context_files:
      - src/types.ts
      - src/autonomous-runner.ts
    variables:
      module_name: context-analyzer
      module_description: >
        Create src/context-analyzer.ts that exports a function analyzeContext(entryFile: string, basePath: string):
        Promise<string[]>. It should read the given TypeScript file, extract all relative import paths (lines matching
        import ... from './...'), resolve them to absolute paths, and recursively follow imports up to 3 levels deep.
        Return a deduplicated array of file paths that are relevant context for that entry file. Use node:fs/promises
        and node:path only. No external dependencies. Export a second function getFileExports(filePath: string):
        Promise<string[]> that reads a file and returns the names of all named exports using regex matching on 'export
        function', 'export class', 'export interface', 'export const', 'export type'. Named exports only.
    started_at: 2026-02-14T18:53:15.425Z
    completed_at: 2026-02-14T18:53:21.800Z
    branch: auto/create-context-analyzer
  - id: create-execution-audit-log
    status: completed
    workflow: auto-implement
    prompt: prompts/auto-create-module.md
    context_files:
      - src/types.ts
      - src/queue-manager.ts
    variables:
      module_name: execution-audit-log
      module_description: >
        Create src/audit-log.ts that exports an interface AuditEntry with fields: id (string), taskId (string),
        timestamp (string ISO), durationMs (number), tokensIn (number), tokensOut (number), estimatedCost (number),
        status ('completed' | 'failed'), filesChanged (string[]), branch (string | undefined), error (string |
        undefined). Export function logEntry(entry: AuditEntry): Promise<void> that appends the entry as a JSON line to
        'audit-log.jsonl' in the project root. Export function loadAuditLog(): Promise<AuditEntry[]> that reads the
        JSONL file and returns all entries. Export function getAuditSummary(): Promise<{ totalRuns: number, successRate:
        number, totalTokensIn: number, totalTokensOut: number, totalCost: number, avgDurationMs: number }> that computes
        summary stats from the log. Use node:fs/promises only. Named exports only.
    started_at: 2026-02-14T18:53:21.805Z
    completed_at: 2026-02-14T18:53:27.348Z
    branch: auto/create-execution-audit-log
  - id: create-diff-preview
    status: completed
    workflow: auto-implement
    prompt: prompts/auto-create-module.md
    context_files:
      - src/git-ops.ts
      - src/autonomous-runner.ts
    variables:
      module_name: diff-preview
      module_description: >
        Create src/diff-preview.ts that exports a function generateDiffPreview(basePath: string): Promise<string>. It
        should run 'git diff --staged' and 'git diff' as child processes (using node:child_process spawn) and return the
        combined diff output as a string. Export a function formatDiffSummary(diff: string): { filesChanged: string[],
        linesAdded: number, linesRemoved: number } that parses a unified diff string and extracts file names from '---
        a/' and '+++ b/' lines, counts lines starting with '+' (added) and '-' (removed), excluding the --- and +++
        header lines. Export a function printDiffPreview(diff: string): void that prints a colorized summary to console
        using ANSI codes (green for additions, red for removals). Use node:child_process and node:path only. Named
        exports only.
    started_at: 2026-02-14T18:53:27.352Z
    completed_at: 2026-02-14T18:53:37.031Z
    branch: auto/create-diff-preview
  - id: create-dependency-graph
    status: completed
    workflow: auto-implement
    prompt: prompts/auto-create-module.md
    context_files:
      - src/types.ts
    variables:
      module_name: dependency-graph
      module_description: >
        Create src/dependency-graph.ts that exports an interface DependencyNode with fields: file (string), imports
        (string[]), importedBy (string[]). Export function buildDependencyGraph(basePath: string): Promise<Map<string,
        DependencyNode>>. It should find all .ts files in src/ using node:fs/promises readdir with recursive option,
        read each file, extract relative import paths using regex matching on lines like import ... from './...' or
        import ... from '../...', resolve them relative to each file's directory, and build a bidirectional graph.
        Export function getModuleDepth(graph: Map<string, DependencyNode>, file: string): number that returns how many
        levels deep a module is (0 for files with no imports). Export function findOrphans(graph: Map<string,
        DependencyNode>): string[] that returns files that are neither imported by anything nor import anything. Export
        function toJSON(graph: Map<string, DependencyNode>): string that serializes the graph to a JSON string. Use
        node:fs/promises and node:path only. Named exports only.
    started_at: 2026-02-14T18:53:37.035Z
    completed_at: 2026-02-14T18:53:46.134Z
    branch: auto/create-dependency-graph
  - id: create-task-cost-tracker
    status: completed
    workflow: auto-implement
    prompt: prompts/auto-create-module.md
    context_files:
      - src/budget-manager.ts
      - src/types.ts
    variables:
      module_name: task-cost-tracker
      module_description: >
        Create src/task-cost-tracker.ts that exports an interface TaskCost with fields: taskId (string), model (string),
        tokensIn (number), tokensOut (number), cost (number), timestamp (string ISO). Export const MODEL_PRICING:
        Record<string, { inputPer1k: number, outputPer1k: number }> with entries for 'gpt-4o' (input: 0.0025, output:
        0.01), 'gpt-4o-mini' (input: 0.00015, output: 0.0006), 'claude-sonnet-4-20250514' (input: 0.003, output: 0.015),
        'claude-haiku' (input: 0.00025, output: 0.00125). Export function calculateCost(model: string, tokensIn: number,
        tokensOut: number): number that looks up the model in MODEL_PRICING and computes the cost, returning 0 if model
        is unknown. Export function trackTaskCost(cost: TaskCost): Promise<void> that appends to 'task-costs.jsonl'.
        Export function getSpendingSummary(): Promise<{ totalCost: number, costByModel: Record<string, number>,
        taskCount: number }> that reads the JSONL and aggregates. Use node:fs/promises only. Named exports only.
    started_at: 2026-02-14T18:53:46.138Z
    completed_at: 2026-02-14T18:53:53.413Z
    branch: auto/create-task-cost-tracker
  - id: create-codebase-health-score
    status: completed
    workflow: auto-implement
    prompt: prompts/auto-create-module.md
    context_files:
      - src/verify-runner.ts
      - src/observabilityUtil.ts
    variables:
      module_name: codebase-health-score
      module_description: >
        Create src/health-score.ts that exports an interface HealthReport with fields: score (number 0-100), timestamp
        (string ISO), metrics (object with: typeScriptErrors: number, totalFiles: number, totalLines: number,
        avgFileSize: number, largestFile: { path: string, lines: number }). Export function computeHealthScore(basePath:
        string): Promise<HealthReport>. It should: 1) run 'npx tsc --noEmit' via spawn and count error lines (lines
        containing ': error TS'), 2) find all .ts files in src/ using readdir recursive, 3) count total lines across all
        files, 4) find the largest file. Score formula: start at 100, subtract 10 per TypeScript error (min 0), subtract
        5 if any file exceeds 500 lines, subtract 5 if avgFileSize exceeds 200 lines. Export function
        trackHealthScore(report: HealthReport): Promise<void> that appends to 'health-scores.jsonl'. Export function
        getHealthTrend(): Promise<HealthReport[]> that reads back all scores. Use node:child_process spawn and
        node:fs/promises. Named exports only.
    started_at: 2026-02-14T18:53:53.418Z
    completed_at: 2026-02-14T18:54:12.296Z
    branch: auto/create-codebase-health-score
  - id: create-webhook-notifier
    status: completed
    workflow: auto-implement
    prompt: prompts/auto-create-module.md
    context_files:
      - src/types.ts
      - src/error-notification.ts
    variables:
      module_name: webhook-notifier
      module_description: >
        Create src/webhook-notifier.ts that exports an interface WebhookPayload with fields: event ('task.completed' |
        'task.failed' | 'batch.completed'), taskId (string | undefined), status (string), message (string), timestamp
        (string ISO), metadata (Record<string, unknown> | undefined). Export function sendWebhook(url: string, payload:
        WebhookPayload): Promise<{ success: boolean, statusCode: number | undefined }> that makes an HTTP POST request
        using node:https (for https URLs) or node:http (for http URLs). Set Content-Type to application/json, timeout to
        5000ms. Return success: true if statusCode is 2xx, false otherwise. Do not throw on failure. Export function
        createTaskCompletedPayload(taskId: string, branch: string, durationMs: number): WebhookPayload and
        createTaskFailedPayload(taskId: string, error: string): WebhookPayload as convenience constructors. Use
        node:http and node:https only. No external dependencies. Named exports only.
    started_at: 2026-02-14T18:54:12.299Z
    completed_at: 2026-02-14T18:54:18.392Z
    branch: auto/create-webhook-notifier
  - id: error-handling-runtime
    status: completed
    workflow: auto
    prompt: prompts/auto-modify-file.md
    context_files:
      - src/adapters/anthropic-adapter.ts
    variables:
      modification_description: >
        Add more comprehensive error handling in the createAnthropicAdapter function to improve runtime safety,
        including logging unexpected error types and making sure all error branches in the Promise flow are correctly
        caught and logged.
    started_at: 2026-02-14T18:54:18.395Z
    completed_at: 2026-02-14T18:54:32.090Z
    branch: auto/error-handling-runtime
  - id: add-tests-anthropic-adapter
    status: failed
    workflow: auto
    prompt: prompts/auto-write-test.md
    context_files:
      - src/adapters/anthropic-adapter.ts
    variables:
      test_target: src/adapters/anthropic-adapter.ts
      test_description: >
        Implement unit tests for the createAnthropicAdapter function, including tests for successful request execution,
        network errors, API limit errors, and rate limit errors.
    started_at: 2026-02-14T18:54:32.094Z
    completed_at: 2026-02-14T18:55:08.888Z
    error: >-
      # Verification Errors


      The following commands failed. Fix ALL errors.


      ## TypeScript Build (exit 2)

      ```

      src/adapters/anthropic-adapter.test.ts(71,16): error TS2345: Argument of type 'string | undefined' is not
      assignable to parameter of type 'string'.
        Type 'undefined' is not assignable to type 'string'.
      src/adapters/anthropic-adapter.test.ts(95,16): error TS2345: Argument of type 'string | undefined' is not
      assignable to parameter of type 'string'.
        Type 'undefined' is not assignable to type 'string'.
      src/adapters/anthropic-adapter.test.ts(119,16): error TS2345: Argument of type 'string | undefined' is not
      assignable to parameter of type 'string'.
        Type 'undefined' is not assignable to type 'string'.
      ```
  - id: add-tests-openai-adapter
    status: completed
    workflow: auto
    prompt: prompts/auto-write-test.md
    context_files:
      - src/adapters/openai-adapter.ts
    variables:
      test_target: src/adapters/openai-adapter.ts
      test_description: >
        Create unit tests for the createOpenAIAdapter function, covering the valid execution paths, timeout scenarios,
        and responses to unauthorized access.
    started_at: 2026-02-14T18:55:08.892Z
    completed_at: 2026-02-14T18:55:19.574Z
  - id: improve-type-coverage
    status: completed
    workflow: auto
    prompt: prompts/auto-modify-file.md
    context_files:
      - src/utils/networkErrorUtil.ts
    variables:
      modification_description: >
        Enhance type safety by adding TypeScript type guards for network and timeout errors, ensuring that all functions
        that handle these errors can properly discriminate between different error types, reducing the risk of runtime
        exceptions.
    started_at: 2026-02-14T18:55:19.581Z
    completed_at: 2026-02-14T18:55:27.621Z
    branch: auto/improve-type-coverage
  - id: create-project-profiles
    status: completed
    workflow: auto
    prompt: prompts/auto-create-module.md
    context_files:
      - src/project-registry.ts
      - src/verify-runner.ts
      - src/scheduler.ts
    variables:
      module_name: project-profiles
      module_description: >
        Create src/project-profiles.ts that exports an interface ProjectProfile with fields: language ('TypeScript' |
        'JavaScript'), codeLang ('typescript' | 'javascript'), fileExt ('ts' | 'js'), moduleSystem (string description
        like 'ES modules (import/export, .js extensions in imports)' or 'CommonJS (require/module.exports)'),
        languageInstructions (string — rules for the LLM about this language), defaultVerify (Array<{ command: string,
        args: string[], optional?: boolean }>), defaultScanDirs (string[]), defaultSkipPatterns (string[]), conventions
        (string — short description of coding patterns). Export const PROJECT_PROFILES: Record<string, ProjectProfile>
        with entries for: 'typescript-node' (TypeScript, ES modules, verify: npx tsc --noEmit, scan: src/, skip:
        node_modules dist .git), 'serverless-js' (JavaScript, CommonJS, verify: npx webpack --mode production, scan:
        src/ handlers/, skip: node_modules .serverless .webpack, conventions: 'Handler pattern: module.exports = {
        handler: async function }. AWS Lambda + DynamoDB + SQS.'), 'react-vite' (TypeScript, ES modules, verify: npm run
        build, scan: src/, skip: node_modules dist), 'nextjs-ts' (TypeScript, ES modules, verify: npm run build, scan:
        src/ app/ pages/, skip: node_modules .next), 'sst-v2' (TypeScript, ES modules, verify: npx tsc --noEmit, scan:
        src/ infra/ packages/, skip: node_modules .sst), 'expo-react-native' (TypeScript, ES modules, verify: npx
        expo-doctor, scan: src/ app/, skip: node_modules .expo). Export function getProfile(projectType: string):
        ProjectProfile | undefined that looks up the type in PROJECT_PROFILES. Export function
        getLanguageVarsFromProfile(profile: ProjectProfile): Record<string, string> that returns a Record with keys:
        language, code_lang, file_ext, module_system, language_instructions mapped from the profile fields. Use no
        external dependencies. Named exports only.
    started_at: 2026-02-14T20:10:36.132Z
    completed_at: 2026-02-14T20:10:44.983Z
    branch: auto/create-project-profiles
  - id: create-project-context
    status: running
    workflow: auto
    prompt: prompts/auto-create-module.md
    context_files:
      - src/project-registry.ts
      - src/task-proposer.ts
    variables:
      module_name: project-context
      module_description: >
        Create src/project-context.ts that exports an async function generateProjectContext(projectPath: string):
        Promise<string>. It should read key project files to build a concise LLM preamble. Steps: 1) Read package.json
        from projectPath — extract name, description, dependencies, devDependencies. 2) Check if tsconfig.json exists —
        if yes, note 'TypeScript project with strict mode' (read strict from compilerOptions). 3) Check if
        serverless.yml or serverless.yaml exists — if yes, note 'Serverless Framework project'. 4) Check if
        sst.config.ts exists — if yes, note 'SST project'. 5) Detect module system: read package.json 'type' field — if
        'module' note 'ES modules', otherwise check for .mjs files in src/, otherwise note 'CommonJS'. 6) List key
        dependencies by category: AWS SDK (@aws-sdk/*), React (react, react-dom), Database (dynamodb, mongoose), Testing
        (jest, vitest, mocha). 7) Sample 3 source files from the project to detect patterns: read up to 50 lines from
        each, extract import style (require vs import), export style (module.exports vs export), and any framework
        patterns. Return a formatted string like: '## Project Context\n- Name: {name}\n- Language: {lang}\n- Module
        System: {system}\n- Framework: {framework}\n- Key Dependencies: {deps}\n- Patterns: {patterns}'. Use
        node:fs/promises and node:path only. Named exports only. Handle missing files gracefully (return partial
        context). Export a second function detectLanguage(projectPath: string): Promise<'TypeScript' | 'JavaScript'>
        that checks for tsconfig.json existence and .ts files in src/.
    started_at: 2026-02-14T20:10:44.992Z
  - id: create-project-detector
    status: pending
    workflow: auto
    prompt: prompts/auto-create-module.md
    context_files:
      - src/project-registry.ts
    variables:
      module_name: project-detector
      module_description: >
        Create src/project-detector.ts that exports an async function detectProjectType(projectPath: string):
        Promise<string>. It auto-detects a project's type based on filesystem markers. Detection logic (check in this
        order, return first match): 1) If sst.config.ts exists → return 'sst-v2'. 2) If app.json exists AND it contains
        'expo' → return 'expo-react-native'. 3) If serverless.yml or serverless.yaml exists → check if tsconfig.json
        also exists: if yes return 'serverless-ts', if no return 'serverless-js'. 4) If next.config.js or
        next.config.mjs or next.config.ts exists → check if tsconfig.json exists: if yes return 'nextjs-ts', if no
        return 'nextjs-js'. 5) If vite.config.ts or vite.config.js exists → check if tsconfig.json exists: if yes return
        'react-vite', if no return 'react-vite-js'. 6) If tsconfig.json exists → return 'typescript-node'. 7) If
        package.json exists → return 'javascript-node'. 8) Otherwise return 'unknown'. Use node:fs/promises to check
        file existence (use access() or stat(), do not throw). Export a second function detectModuleSystem(projectPath:
        string): Promise<'esm' | 'commonjs'> that reads package.json 'type' field — if 'module' return 'esm', otherwise
        check for .mjs files in the root, otherwise return 'commonjs'. Export a third function fileExists(filePath:
        string): Promise<boolean> as a utility. Use node:fs/promises and node:path only. Named exports only.
  - id: create-protected-files-config
    status: pending
    workflow: auto
    prompt: prompts/auto-create-module.md
    context_files:
      - src/file-writer.ts
      - src/security-scanner.ts
    variables:
      module_name: protected-files-config
      module_description: >
        Create src/protected-files-config.ts that exports an interface ProtectedFilesConfig with fields: files
        (Set<string>) — the file paths that cannot be overwritten, patterns (string[]) — glob-like patterns to match
        (e.g., '*.config.*', 'package.json'). Export const ORCHESTRATOR_PROTECTED: ProtectedFilesConfig with files
        matching the current PROTECTED_FILES in file-writer.ts (src/types.ts, src/cli.ts, src/config.ts,
        src/autonomous-runner.ts, src/scheduler.ts, src/queue-manager.ts, src/task-proposer.ts, src/file-writer.ts,
        src/verify-runner.ts, src/git-ops.ts, src/workflow-runner.ts, src/prompt-resolver.ts, src/state-manager.ts,
        package.json, tsconfig.json, AGENTS.md) and patterns as empty array. Export const COMMON_CONFIG_PROTECTED:
        ProtectedFilesConfig with files as empty Set, patterns as ['package.json', 'package-lock.json', 'tsconfig.json',
        '*.config.ts', '*.config.js', 'serverless.yml', 'serverless.yaml', '.eslintrc*', '.prettierrc*',
        'sst.config.ts']. Export function getProtectedFiles(projectId: string, projectType?: string):
        ProtectedFilesConfig that returns ORCHESTRATOR_PROTECTED if projectId is 'orchestrator', otherwise returns
        COMMON_CONFIG_PROTECTED. Export function isProtected(filePath: string, config: ProtectedFilesConfig): boolean
        that checks if the file matches any entry in files Set OR if the file basename matches any pattern using simple
        glob matching (only support * wildcard at start — e.g., '*.config.ts' matches 'vite.config.ts'). Use no external
        dependencies. Named exports only.
